<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0"/>
  <title>Parallelizing Bor&#367vka's Algorithm</title>

  <!-- CSS  -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>
</head>
<body>
  <header>
    <nav class="indigo" role="navigation">
      <div class="nav-wrapper container"><a id="logo-container" href="#" class="brand-logo">15-418 Final Project</a>
        <ul class="right hide-on-med-and-down">
          <li><a href="#">Proposal</a></li>
          <li><a href="#">Check Point</a></li>
          <li><a href="#">Final Write-Up</a></li>
        </ul>
  
        <ul id="nav-mobile" class="side-nav">
          <li><a href="#">Proposal</a></li>
          <li><a href="#">Check Point</a></li>
          <li><a href="#">Final Write-Up</a></li>
        </ul>
        <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
      </div>
    </nav>
  </header>

  <main>
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h2>Parallelizing Bor&#367vka's Algorithm and Applying it to Image Segmentation</h2>
            <p>By Kathleen Fuh and Shreya Vemuri</p> 
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Summary</h4>
            <p>We plan to parallelize Bor&#367vka’s algorithm for finding minimum spanning trees and plan to optimize its performance on a CPU using OpenMP and on a GPU using CUDA. We hope to analyze and optimize the performance of our implementations and apply it to image segmentation. While we acknowledge the existence of current approaches to parallelize this algorithm, we hope to use those ideas to find an implementation that best suits the machines we end up using</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Background</h4>
            <p>A spanning tree of a connected, undirected graph <i>G</i> with vertex set <i>V</i> and edge set <i>E</i> is a connected subgraph of <i>G</i> that includes all vertices of <i>G</i> and exactly |<i>V</i>|-1 edges. When given a connected, weighted, undirected graph, the minimum spanning tree (MST) is a spanning tree with minimum total edge weight.</p>
            <p>The key property that drives many MST algorithms is the light edge property. This property states that for any cut of a connected, undirected, weighted graph <i>G</i>, the edge with minimum weight that crosses the cut must be in the MST.</p>
            <p>Bor&#367vka’s algorithm is a well-known parallel algorithm for finding MSTs. It makes use of the light edge property by observing that the minimum weight edge incident on any vertex <i>v</i> must be in the MST (the cut of the graph in this case partitions the graph into one set containing the single vertex <i>v</i> and a second set containing the rest of the graph). This observation introduces an axis of parallelism along vertices because edges in the MST can be selected in parallel by looking at each vertex. Using this idea, Bor&#367vka’s algorithm works as follows</p>
            <p>While there are still edges:</p>
            <ol>
              <li>Find the minimum weight edge incident on each vertex (these edges will form at least one connected component)</li>
              <li>Contract each connected component, creating a new super vertex for all vertices in the component</li>
              <li>Remove all self edges of the super vertex</li>
              <li>Add the minimum weight edge between super vertices to the MST and remove all other redundant edges.</li>
            </ol>
            <p>Ideas for axes of parallelism include parallelizing over the components or over the vertices within each time step of the algorithm. It will also be interesting to explore other axes of parallelism such as edges when the number of components in the graph is large. Bor&#367vka’s algorithm can also be implemented using star contraction which we hope to incorporate into our algorithm once we are ready to implement image segmentation which uses that method.</p>
            <p>Image segmentation is the process of partitioning a digital image into many sets of pixels with the intent to reduce the image to a simpler form, making it easier to analyze. It makes use of Bor&#367vka’s algorithm by treating every pixel as a vertex with some assigned credit indicating how “segmented” that part of the image will be in the final result. Each edge and corresponding weight represents the difference of pixel color of the two vertices that are at the endpoints. Using contraction based on edge weights, credits are reassigned, and edges are filtered. This process continues until no edges are left over.</p>
            <p>An example is given in the image below:</p>
            <img src="images/image-segment.png" alt="Segmented Image" style="width:400px;height:300px;"/>
            </ol>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Challenges</h4>
            <p>One of the challenges in this project will be to determine how to represent the connected components in the graph. We will have to implement a union-find data structure (or something similar to it) in order to keep track of these sets. Bor&#367vka’s algorithm requires modifying this data structure in order to keep track of super vertices and edges in our MST, so one challenge will be in parallelizing this step, and avoiding race conditions. We saw a similar issue in assignment 3 where we had to minimize the number of atomic sections that we had when using OpenMP in order to see good speedup. Another issue in CUDA will be in figuring out how to best assign the work for each thread block, and how to best utilize shared memory in the cases with large graphs.</p>
            <p>Additionally, neither of us have experience in image processing so representing, modifying, and displaying the images may serve as a challenge. We are excited to learn some more about image processing. It will be fun to see this real-world application run on CPUs and GPUs while putting the knowledge we have learned about parallelism this semester to use.</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Resources</h4>
            <p>We will be using the Gates machines. We will be basing our sequential and parallel code off of the pseudocode provided in <a href="https://drive.google.com/file/d/0B4z2gzEmkDDCTUhKUWxJQnR0bEk/view">15-210’s notes</a>. This is a very basic starting point to provide structure as their notes are catered towards functional programming. We will also have to design a union-find data structure (or something similar) and look into graph contraction algorithms.</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Goals & Deliverables</h4>
            <p>By the end of the project, we plan to achieve the following:</p>
            <ul>
                <li>A working baseline sequential Borv&#367ka implementation</li>
                <li>A parallel algorithm for the CPU and a parallel algorithm for the GPU</li>
                <li>Relative linear speedup with the number of cores on a CPU up to some point</li>
            </ul>
            <p>By the end of the project, we hope to achieve the following:</p>
            <ul>
                <li>A GPU implementation that achieves a speedup close to that of the CPU</li>
                <li>An application of the algorithm to image segmentation (if time permits - right now, it is in our schedule to do so)</li>
            </ul>
            <p>By the end of this project, we plan to demo the following:</p>
            <ul>
                <li>Graphs depicting the performance of our sequential algorithm versus the performance of our implementations on a CPU versus on a GPU. We also would like to show graphs comparing performance on a varied number of cores for a CPU in order to determine what the optimal number of cores is on the CPU for some given graph</li>
                <li>Results of image segmentation on some chosen pictures</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Platform Choice</h4>
            <p>We will be coding in C++ and parallelizing with OpenMP for the CPU implementation and with CUDA for the GPU implementation. We chose these platforms so we can see how the technologies we used in class this semester can be used in real-life applications. Based on past homework assignments such as assignment 3 that also involved parallelizing graph algorithms, we think these platforms will be sufficient for the workload of our implementation. We are also using our plan of developing with two different technologies as a process for learning why certain choices on particular machines make more sense for the workload we have chosen.</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Schedule</h4>
            <table style="width:100%">
                <tr>
                    <td><b>Week</b></td>
                    <td><b>Plan</b></td>
                </tr>
                <tr>
                    <td><b>April 4 - April 10</b></td>
                    <td>Implement sequential version of Bor&#367vka</td>
                </tr>
                <tr>
                    <td><b>April 11 - April 17</b></td>
                    <td>Parallel implementation of Bor&#367vka on CPU using OpenMP</td>
                </tr>
                <tr>
                    <td><b>April 18 - April 24</b></td>
                    <td>Parallel implementation of Bor&#367vka on GPU using CUDA</td>
                </tr>
                <tr>
                    <td><b>April 25 - May 1</b></td>
                    <td>Apply implementations to image segmentation</td>
                </tr>
                <tr>
                    <td><b>May 2 - May 8</b></td>
                    <td>Analysis of results/buffer window/presentation preparation</td>
                </tr>
            </table>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="page-footer  indigo darken-3">
    <div class="container">
      <div class="row">
        <div class="col l6 s12">
          <h5 class="white-text">15-418 Final Project</h5>
          <p class="grey-text text-lighten-4">by Kathleen Fuh and Shreya Vemuri</p>
          <a href="https://github.com/kfuh1/15418-project.git" target="_blank">GitHub Repository</a>

        </div>
      </div>
    </div>
    <div class="footer-copyright">
      <div class="container">
      Made by <a class="indigo-text text-accent-1" href="http://materializecss.com">Materialize</a>
      </div>
    </div>
  </footer>


  <!--  Scripts-->
  <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="js/materialize.js"></script>
  <script src="js/init.js"></script>

  </body>
</html>
