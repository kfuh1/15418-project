<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0"/>
  <title>Parallelizing Bor&#367vka's Algorithm</title>

  <!-- CSS  -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
  </style>
</head>
<body>
  <header>
    <nav class="indigo" role="navigation">
      <div class="nav-wrapper container"><a id="logo-container" href="#" class="brand-logo">15-418 Final Project</a>
        <ul class="right hide-on-med-and-down">
          <li><a href="index.html">Proposal</a></li>
          <li><a href="checkpoint.html">Check Point</a></li>
          <li><a href="#">Final Write-Up</a></li>
        </ul>
  
        <ul id="nav-mobile" class="side-nav">
          <li><a href="index.html">Proposal</a></li>
          <li><a href="checkpoint.html">Check Point</a></li>
          <li><a href="#">Final Write-Up</a></li>
        </ul>
        <a href="#" data-activates="nav-mobile" class="button-collapse"><i class="material-icons">menu</i></a>
      </div>
    </nav>
  </header>

  <main>
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h2>Parallelizing Bor&#367vka's Algorithm</h2>
            <h3>(Final Writeup)</h3>
            <p>By Kathleen Fuh (kfuh) and Shreya Vemuri (shreyav)</p> 
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Summary</h4>
            <p>For our project, we wrote a sequential version of Borůvka’s algorithm for finding minimum spanning trees in C++ and optimized its performance on a CPU using OpenMP and parallelizing techniques. In the process of parallelizing, we explored both edge and star contraction techniques for Bor&#367vka’s algorithm. We then analyzed the performance on the GHC machines with various numbers of threads.</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Background</h4>
            <p>A spanning tree of a connected, undirected graph <i>G</i> with vertex set <i>V</i> and edge set <i>E</i> is a connected subgraph of <i>G</i> that includes all vertices of <i>G</i> and exactly |<i>V</i>|-1 edges. When given a connected, weighted, undirected graph, the minimum spanning tree (MST) is a spanning tree with minimum total edge weight.</p>
            <p>The key property that drives many MST algorithms is the light edge property. This property states that for any cut of a connected, undirected, weighted graph <i>G</i>, the edge with minimum weight that crosses the cut must be in the MST.</p>
            <p>Bor&#367vka’s algorithm is a well-known parallel algorithm for finding MSTs. It makes use of the light edge property by observing that the minimum weight edge incident on any vertex <i>v</i> must be in the MST (the cut of the graph in this case partitions the graph into one set containing the single vertex <i>v</i> and a second set containing the rest of the graph). This observation introduces an axis of parallelism along vertices because edges in the MST can be selected in parallel by looking at each vertex. Using this idea, Bor&#367vka’s algorithm works as follows</p>
            <p>While there are still edges:</p>
            <ol>
              <li>Find the minimum weight edge incident on each vertex (these edges will form at least one connected component)</li>
              <li>Contract each connected component, creating a new super vertex for all vertices in the component</li>
              <li>Add the minimum weight edge between super vertices to the MST and remove all other redundant edges.</li>
            </ol>
            <p>There are two different techniques to approaching this algorithm when contracting the graph: edge contraction and star contraction:</p>
            <ol>
              <li><b>Edge contraction</b>: Edge contraction involves finding the min edge incident to each vertex (in the first iteration) and each component thereafter. We then add these edges to our MST and perform the necessary contractions in the contraction stage. This utilizes the light-end property as was discussed above</li>
              <li><b>Star contraction</b>: Star contraction involves flipping a coin for each vertex/ component and finding the heads and tails. This is necessary in star contraction, so we contract into the head and so that we can determine what are the star centers and star satellites. Particularly, we make 0 mean you are a satellite (false) and 1 mean you are a star center (true).</li>
            </ol>
            <p>Here are some <b>implementation details</b>: Our algorithm takes in a graph structure as input and prints out the edges of the MST</p>
            <p><b>Key data structures:</b></p>
            <ul>
              <li><b>Union find data structure</b>: Our union find is based on having a struct which holds information about the parent and rank of each node. This allows us to store information about which component each node belongs to in order to determine which edges are valid edges to contract.</li>
              <li><b>Graph representation</b>: We model the undirected graph with an underlying representation of a directed graph (so a directed edge is listed in the graph twice for the two directions). We based our representation off of the representation used in assignment 3. (Please see the Approach section for more information on how we decided on our graph representation).
              </li>
            </ul>
            <p><b>Key operations:</b></p>
            <ul>
              <li>Find parent and union (read a paper which used compare and swap and that worked pretty well and allowed us to not have to lock up an entire section in order to call these functions)</li>
              <li>We didn’t use the rank attribute for the parallel version of Boruvka’s because that would require an atomic increment which we thought wouldn’t be worth it</li>
            </ul>
            <p><b>Excessive computation and dependency challenges:</b></p>
            <ul>
              <li>The algorithm is broken down into two main components: finding minimum edges out of each component and contracting the graph, each of which posed its own challenges throughout the process of parallelizing</li>
              <li>Finding min edges could be computationally expensive based on what axis of parallelism is necessary, especially since we were using the same graph on every iteration rather than actually creating a new contracted graph. We found that we were doing extra work here and had to change our approach as we explain in the next section</li>
              <li>The contraction stage also had dependencies based on the union-find operations that were done on both endpoints of the edge being contracted. This introduced a critical region that we had to fix. Our approach to account for this is also explained in the next section</li>
            </ul>
            <p><b>Other challenges:</b></p>
            <ul>
              <li>Creating graphs (explained in the Approach section)</li>
              <li>Writing a lock-free union data structure, so that we could decrease the granularity of our locking and critical sections</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Approach</h4>
            <p></p>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>Results</h4>
            <p></p>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="section">
        <div class="row">
          <div class="col s12 m12">
            <h4>References</h4>
            <p></p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer class="page-footer  indigo darken-3">
    <div class="container">
      <div class="row">
        <div class="col l6 s12">
          <h5 class="white-text">15-418 Final Project</h5>
          <p class="grey-text text-lighten-4">by Kathleen Fuh and Shreya Vemuri</p>
          <a href="https://github.com/kfuh1/15418-project.git" target="_blank">GitHub Repository</a>

        </div>
      </div>
    </div>
    <div class="footer-copyright">
      <div class="container">
      Made by <a class="indigo-text text-accent-1" href="http://materializecss.com">Materialize</a>
      </div>
    </div>
  </footer>


  <!--  Scripts-->
  <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="js/materialize.js"></script>
  <script src="js/init.js"></script>

  </body>
</html>
